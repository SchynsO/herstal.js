{"version":3,"sources":["herstal.shared.min.js"],"names":["_typeof","Symbol","iterator","obj","constructor","Character","player","position","orientation","options","this","world","inputs","weapons","currentWeapon","characterModel","health","ATTRIBUTES","defaultHealth","maxHealth","armor","defaultArmor","maxArmor","isDead","dim","dimensions","DIMENSIONS","head_w","head_h","body_w","body_h","body_c","vertices","length","x","y","z","isGounded","isCrounched","jumpTimer","platform","head_pos","body_pos","head_shape","CANNON","Box","body_shape","team","filter","FILTERS","group","mask","body","Body","mass","material","MATERIAL","fixedRotation","collisionFilterGroup","collisionFilterMask","addShape","character","isHead","Player","id","name","colors","model","World","step","HERSTALshared","__FPS","cannonWorld","gravity","set","defaultContactMaterial","friction","worldRender","characterMaterial","Material","addContactMaterial","ContactMaterial","WORLD","defaultMaterial","restitution","contactEquationStiffness","contactEquationRelaxation","characters","window","module","exports","require","Error","Vec3","prototype","getAngle","v","v1","clone","v2","UNIT_Y","normalize","Math","acos","dot","Array","addElement","e","index","indexOf","removeElement","splice","setFromInput","o","movement","m","jump","i","crounch","fire1","fire2","use","reload","melee","zoom","weapon","w","setFromData","data","setLook","p","copy","velocity","g","isGrounded","c","getData","updateAll","updateGround","updateMove","updateCrounch","updatePlatform","setWeapon","PI2","PI","hPI","addRotation","angle","axis","sqrLength","sqrt","theta","speed","crounchedSpeed","moveSpeed","cos","sin","jumpForce","vert","vadd","shapes","halfExtents","result","checkCollision","hasHit","hitNormalWorld","steepSlope","type","KINEMATIC","hasChanged","updatePlatformPosition","newGlobalPos","pointToWorldFrame","localPos","translation","vsub","globalPos","newGlobalRot","quaternion","mult","localRot","rotationDiff","globalRot","inverse","vec","toEuler","pointToLocalFrame","canGetUp","h","shape","offset","shapeOffsets","inc","crounchIncrement","body_height","newWeap","incre","stop","getDamage","damage","armorDamage","armorProtection","getHealth","getArmor","killed","callback","fw","fh","fc","hw","hh","bw","bh","bc","vertice","padding","arguments","undefined","from","to","ray","Ray","intersectWorld","mode","CLOSEST","skipBackfaces","none","alpha","beta","createCharacter","update","addCharacter","addBody","addCharacterModel","removeCharacter","removeBody","FILTER"],"mappings":"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","file":"herstal.shared.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function () {\n\tvar HERSTALshared = {\n\t\t__FPS: 60 // we fix the overall update to 60FPS\n\t};\n\n\t// we use a hack to be able to use the library in both node an the browser\n\t// if window is not set, we will have an error\n\tif (!window) window = {};\n\t// if module is not set, we will have an error\n\tif (!module) module = {};\n\n\t// the library must be usable in both node and browser\n\tmodule.exports = window.HERSTALshared = HERSTALshared;\n\n\t// Cannon is either already part of the html page or is a module to import\n\tvar CANNON = CANNON || require('./cannon.js');\n\tif (!CANNON) throw new Error('Herstal.shared needs CANNON.js to work');\n\n\t// adds function for CANNON.js objects\n\t/**\r\n  * Get the angle between this vector and the given vector.\r\n  * @method getAngle\r\n  * @param {Vec3} v Vector to get the angle from\r\n  * @return {number}\r\n  */\n\tCANNON.Vec3.prototype.getAngle = function (v) {\n\t\t// we need two vectors\n\t\tvar v1 = this.clone();\n\t\tvar v2 = v ? new CANNON.Vec3(v.x, v.y, v.z) : CANNON.Vec3.UNIT_Y;\n\n\t\t// acos(dot(v1 / norm(v1), v2 / norm(v2)))\n\t\tv1.normalize();\n\t\tv2.normalize();\n\t\treturn Math.acos(v1.dot(v2));\n\t};\n\t/**\r\n  * Add element only if it's not already present in the list\r\n  */\n\tArray.prototype.addElement = function (e) {\n\t\tvar index = this.indexOf(e);\n\t\t// if the element is not already in the list\n\t\t// we add it to the end of the list\n\t\tif (index == -1) {\n\t\t\tthis[this.length] = e;\n\t\t\t// we return the position of the element in the array\n\t\t\treturn this.length - 1;\n\t\t}\n\t\treturn -1; // the element was already in the array\n\t};\n\t/**\r\n  * Remove an element from the list\r\n  */\n\tArray.prototype.removeElement = function (e) {\n\t\tvar index = this.indexOf(e);\n\t\t// if the element is in the list\n\t\t// we can remove it\n\t\tif (index > -1) this.splice(index, 1);\n\t\t// we return the old position of the element in the array\n\t\treturn index;\n\t};\n\n\t/**\r\n  * Base class for all characters\r\n  */\n\t/* CONSTRUCTOR */\n\tfunction Character(player, position, orientation, options) {\n\t\toptions = options || {};\n\n\t\t// the world in which the character exists\n\t\tthis.world = null;\n\t\tthis.player = player;\n\t\tthis.inputs = null;\n\t\t// weapons of the character (max should be 10)\n\t\tthis.weapons = []; // the array needs atleast one weapon\n\t\tthis.currentWeapon = 0;\n\n\t\t// characterModel used in HERSTALclient\n\t\tthis.characterModel = null;\n\n\t\t// status of the character\n\t\tthis.health = options.health || Character.ATTRIBUTES.defaultHealth;\n\t\tthis.maxHealth = options.maxHealth || Character.ATTRIBUTES.maxHealth;\n\t\tthis.armor = options.armor || Character.ATTRIBUTES.defaultArmor;\n\t\tthis.maxArmor = options.maxArmor || Character.ATTRIBUTES.maxArmor;\n\t\tthis.isDead = false;\n\n\t\t// we recover the potentia custom dimensions of the character\n\t\tvar dim = this.dimensions = options.dimensions || Character.DIMENSIONS;\n\t\t// we correct the dimensions if needed\n\t\tdim.head_w = dim.head_w > 0 ? dim.head_w : Character.DIMENSIONS.head_w;\n\t\tdim.head_h = dim.head_h > 0 ? dim.head_h : Character.DIMENSIONS.head_h;\n\t\tdim.body_w = dim.body_w > 0 ? dim.body_w : Character.DIMENSIONS.body_w;\n\t\tdim.body_h = dim.body_h > 0 ? dim.body_h : Character.DIMENSIONS.body_h;\n\t\tdim.body_c = dim.body_c > 0 ? dim.body_c : Character.DIMENSIONS.body_c;\n\t\tif (!dim.vertices) dim.vertices = Character.DIMENSIONS.vertices;else if (dim.vertices.length < 0) dim.vertices = Character.DIMENSIONS.vertices;\n\n\t\t// position of the new character\n\t\tposition = position || { x: 0, y: 0, z: 0 };\n\t\t// the origin of the character will be placed at neck level\n\t\tposition.y += dim.body_h;\n\n\t\t// the orientation of the head (not a quaternion)\n\t\tthis.orientation = orientation || { x: 0, y: 0 };\n\n\t\t// state of the character\n\t\tthis.isGounded = false;\n\t\tthis.isCrounched = false;\n\t\t// jump timer gives a time interval in which the character can jump\n\t\tthis.jumpTimer = 0;\n\t\t// contains the information about the moving platform the character is standing on\n\t\tthis.platform = null; // only requiered for moving platforms\n\n\t\t// relative position of the shapes of the character\n\t\tvar head_pos = { x: 0, z: 0, y: 0.5 * dim.head_h };\n\t\tvar body_pos = { x: 0, z: 0, y: -0.5 * dim.body_h };\n\t\t// shapes of the character\n\t\tvar head_shape = new CANNON.Box({ x: dim.head_w, y: dim.head_h, z: dim.head_w });\n\t\tvar body_shape = new CANNON.Box({ x: dim.body_w, y: dim.body_h, z: dim.body_w });\n\n\t\t// we recover the filter based on the team of the player\n\t\tvar team = options.team || \"none\";\n\t\tvar filter = Character.FILTERS[team];\n\t\tif (!filter) filter = { group: 7, mask: 7 }; // NO TEAM\n\n\t\t// we create the body collider of the character\n\t\tthis.body = new CANNON.Body({\n\t\t\tposition: position,\n\t\t\tmass: 10,\n\t\t\tmaterial: Character.MATERIAL,\n\t\t\tfixedRotation: true,\n\t\t\tcollisionFilterGroup: filter.group,\n\t\t\tcollisionFilterMask: filter.mask\n\t\t});\n\t\t// we add both shapes to the body\n\t\tthis.body.addShape(body_shape, body_pos); // shape 0 = body\n\t\tthis.body.addShape(head_shape, head_pos); // shape 1 = head\n\n\t\t// we add more information to the bodies\n\t\tthis.body.character = this; // a reference to the character\n\t\thead_shape.isHead = true; // this shape is the head\n\t}\n\t// we add the class to the module\n\tHERSTALshared.Character = Character;\n\tCharacter.prototype.constructor = Character;\n\n\t/* SETTER GETTER */\n\t/**\r\n  * to avoid overflood json files with names, we use short names:\r\n  * o : orientation\r\n  * m : movement\r\n  * i : array of bits :\r\n  ** [0] jump\r\n  ** [1] crounch\r\n  ** [2] fire1\r\n  ** [3] fire2\r\n  ** [4] use\r\n  ** [5] reload\r\n  ** [6] melee\r\n  ** [7] zoom\r\n  * w : weapon slot\r\n  */\n\t/**\r\n  * store all of the inputs set over JSON\r\n  */\n\tCharacter.prototype.setFromInput = function (inputs) {\n\t\tif ((typeof inputs === 'undefined' ? 'undefined' : _typeof(inputs)) !== \"object\") return; // if inputs is empty, there is nothing to do\n\t\tthis.inputs = {};\n\n\t\tthis.inputs.orientation = inputs.o;\n\t\tthis.inputs.movement = inputs.m;\n\t\tthis.inputs.jump = !!(inputs.i & 1);\n\t\tthis.inputs.crounch = !!(inputs.i & 2);\n\t\tthis.inputs.fire1 = !!(inputs.i & 4);\n\t\tthis.inputs.fire2 = !!(inputs.i & 8);\n\t\tthis.inputs.use = !!(inputs.i & 16);\n\t\tthis.inputs.reload = !!(inputs.i & 32);\n\t\tthis.inputs.melee = !!(inputs.i & 64);\n\t\tthis.inputs.zoom = !!(inputs.i & 128);\n\t\tthis.inputs.weapon = inputs.w;\n\t};\n\t/**\r\n  * to avoid overflood json files with names, we use short names:\r\n  * o : orientation\r\n  * p : position\r\n  * v : velocity\r\n  * g : isGrounded\r\n  * c : isCrounched\r\n  */\n\t/**\r\n  * set all of the position and movement of the character from the data object\r\n  */\n\tCharacter.prototype.setFromData = function (data) {\n\t\tif ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== \"object\") return; // if data is empty, there is nothing to do\n\t\t// we update the orientation of the character\n\t\tthis.setLook(data.o);\n\n\t\t// if the position is set\n\t\tif (_typeof(data.p) === \"object\") {\n\t\t\t// if position is a vector 3\n\t\t\tif (_typeof(data.p.x) === _typeof(data.p.y) === _typeof(data.p.z) === \"number\") {\n\t\t\t\tthis.body.position.copy(data.p);\n\t\t\t}\n\t\t}\n\t\t// if the velocity is set\n\t\tif (_typeof(data.v) === \"object\") {\n\t\t\t// if velocity is a vector 3\n\t\t\tif (_typeof(data.v.x) === _typeof(data.v.y) === _typeof(data.v.z) === \"number\") {\n\t\t\t\tthis.body.velocity.copy(data.v);\n\t\t\t}\n\t\t}\n\t\t// if grounded and crounched are set\n\t\tif (data.g !== null) this.isGrounded = data.g;\n\t\tif (data.c !== null) this.isCrounched = data.c;\n\t};\n\t/**\r\n  * read all of the position and movement of the character and create a object out of them\r\n  */\n\tCharacter.prototype.getData = function () {\n\t\treturn {\n\t\t\to: this.orientation,\n\t\t\tp: {\n\t\t\t\tx: this.body.position.x,\n\t\t\t\ty: this.body.position.y,\n\t\t\t\tz: this.body.position.z\n\t\t\t},\n\t\t\tv: {\n\t\t\t\tx: this.body.velocity.x,\n\t\t\t\ty: this.body.velocity.y,\n\t\t\t\tz: this.body.velocity.z\n\t\t\t},\n\t\t\tg: this.isGrounded,\n\t\t\tc: this.isCrounched\n\t\t};\n\t};\n\n\t/* UPDATE FUNCTIONS */\n\t/**\r\n  * Global update function of the character\r\n  */\n\tCharacter.prototype.updateAll = function () {\n\t\tvar inputs = this.inputs || {};\n\n\t\t// where the character is looking at ?\n\t\tthis.setLook(inputs.orientation);\n\t\t// is the character on the ground ?\n\t\tthis.updateGround();\n\t\t// in which direction the character is moving, is he jumping ?\n\t\tthis.updateMove(inputs.movement, inputs.jump);\n\t\t// is the character crounching ?\n\t\tthis.updateCrounch(inputs.crounch);\n\t\t// if the character is on a platform, we should record it's position\n\t\tthis.updatePlatform();\n\t\t// we update the weapon the character is holding\n\t\tthis.setWeapon(inputs.weapon);\n\t};\n\t/**\r\n  * Allow the character to look around\r\n  * calculation based on mouse delta is performed client side\r\n  */\n\tCharacter.prototype.setLook = function (orientation) {\n\t\t// if orientation is set\n\t\tif (orientation) {\n\t\t\tvar PI2 = Math.PI * 2,\n\t\t\t    hPI = Math.PI * 0.5;\n\t\t\t// we keep angle in the [ -2PI, 2PI ] interval\n\t\t\torientation.x %= PI2;\n\t\t\torientation.y %= PI2;\n\t\t\t// we cap the angle on the Y-axis within [ -PI/2, PI/2 ] interval\n\t\t\tif (orientation.y > hPI) orientation.y = hPI;else if (orientation.y < -hPI) orientation.y = -hPI;\n\t\t\t// we apply the orientation\n\t\t\tthis.orientation = orientation;\n\t\t}\n\t};\n\t/**\r\n  * Allow to add more rotation to the character on the Y-axis\r\n  */\n\tCharacter.prototype.addRotation = function (angle) {\n\t\t// we add the angle on the Y-axis\n\t\tthis.orientation.x += angle;\n\t\tthis.orientation.x %= Math.PI * 2;\n\t};\n\t/**\r\n  * Allow the character to move around\r\n  * Movement calculation is performed both client and server side\r\n  * server has the authority over the client\r\n  */\n\tCharacter.prototype.updateMove = function (axis, jump) {\n\t\t// if axis is not set, we set it to vector null\n\t\taxis = axis || { x: 0, y: 0 };\n\n\t\t// we normalize the vector to avoid cheating\n\t\tvar sqrLength = axis.x * axis.x + axis.y * axis.y;\n\t\tif (sqrLength > 1) {\n\t\t\tvar length = Math.sqrt(sqrLength);\n\t\t\taxis.x /= length;\n\t\t\taxis.y /= length;\n\t\t}\n\n\t\t// we need the angle on the x axis (horizontal plane)\n\t\tvar theta = this.orientation.x;\n\t\tvar speed = this.isCrounched ? Character.ATTRIBUTES.crounchedSpeed : Character.ATTRIBUTES.moveSpeed;\n\n\t\t// we create a new velocity vector\n\t\tvar velocity = {\n\t\t\ty: this.body.velocity.y,\n\t\t\tx: (axis.x * Math.cos(theta) - axis.y * Math.sin(theta)) * speed,\n\t\t\tz: (-axis.x * Math.sin(theta) - axis.y * Math.cos(theta)) * speed\n\t\t};\n\n\t\t// if the player pressed the jump input\n\t\tif (jump) this.jumpTimer = Character.ATTRIBUTES.jumpTimer;\n\n\t\t// if the jump timer is set, we decreament it\n\t\tif (this.jumpTimer > 0) --this.jumpTimer;\n\n\t\t// if the character is on the ground\n\t\tif (this.isGrounded) {\n\t\t\t// if the character wants to jump\n\t\t\tif (this.jumpTimer > 0) {\n\t\t\t\t// we reset the timer, the character jumps once\n\t\t\t\tthis.jumpTimer = 0;\n\t\t\t\t// we apply a vertical velocity\n\t\t\t\tvelocity.y = Character.ATTRIBUTES.jumpForce;\n\t\t\t}\n\t\t} else {\n\t\t\t// in the air, the new velocity is influenced by the old one\n\t\t\t// new_vel = new_vel/2 + old_vel/2;\n\t\t\tvelocity.x += this.body.velocity.x;\n\t\t\tvelocity.z += this.body.velocity.z;\n\t\t\tvelocity.x *= 0.5;\n\t\t\tvelocity.z *= 0.5;\n\t\t}\n\t\tthis.body.velocity = velocity;\n\t};\n\t/**\r\n  * Function to know if the character is on the ground or not\r\n  */\n\tCharacter.prototype.updateGround = function () {\n\t\t// we reset the state of the character\n\t\tthis.isGrounded = false;\n\t\t// we try each vertices we have defined for characters\n\t\tfor (var i = 0; i < this.dimensions.vertices.length; ++i) {\n\n\t\t\t// for each vertice, we move it from local to global coords\n\t\t\tvar vert = this.body.vadd(this.dimensions.vertices[i]);\n\t\t\t// we put the vertice at the base of the body shape\n\t\t\tvert.y -= this.body.shapes[0].halfExtents.y * 2; // shape 0 is body\n\n\t\t\t// we recover the result of the contact with the ground\n\t\t\tvar result = Character.checkCollision(this.body.world, vert, -0.1);\n\t\t\tif (result.hasHit) {\n\n\t\t\t\t// the angle between the surface normal and the vector up\n\t\t\t\tvar angle = result.hitNormalWorld.getAngle(CANNON.Vec3.UNIT_Y);\n\t\t\t\t// if the ground on which the character stand is not too steep\n\t\t\t\tif (angle < Character.ATTRIBUTES.steepSlope) {\n\n\t\t\t\t\t// we are on a ground\n\t\t\t\t\tthis.isGrounded = true;\n\t\t\t\t\t// if the platform on which we land is kinematic\n\t\t\t\t\tif (result.body.type === CANNON.Body.KINEMATIC) {\n\n\t\t\t\t\t\t// did we changed of platform ?\n\t\t\t\t\t\tvar hasChanged = false;\n\t\t\t\t\t\tif (!platform) hasChanged = true;else if (platform.body !== result.body) hasChanged = true;\n\t\t\t\t\t\t// if the platform has changed, we need to update the platform\n\t\t\t\t\t\tif (hasChanged) {\n\t\t\t\t\t\t\tthis.platform = { body: result.body };\n\t\t\t\t\t\t\tthis.updatePlatform();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we landed on a platform which is not kinematic\n\t\t\t\t\t\tthis.platform = null;\n\t\t\t\t\t}\n\t\t\t\t\t// we've found one contact point\n\t\t\t\t\treturn; // we don't need to check the others\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.platform = null;\n\t};\n\t/**\r\n  * Update the position of the character based on the position of the platform he is standing on\r\n  * /!\\ Should be called after physic engine calculations /!\\\r\n  */\n\tCharacter.prototype.updatePlatformPosition = function () {\n\t\tvar p = this.platform;\n\t\tif (p) {\n\t\t\t// if the character is standing on a platform\n\n\t\t\t// we calculate the movement of the platform since the last update\n\t\t\tvar newGlobalPos = p.pointToWorldFrame(p.localPos);\n\t\t\tvar translation = newGlobalPos.vsub(p.globalPos);\n\t\t\t// we apply the movement to the player\n\t\t\tthis.body.position = this.body.position.vadd(translation);\n\n\t\t\t// we calculate the rotation of the platform since the last update\n\t\t\tvar newGlobalRot = p.body.quaternion.mult(p.localRot);\n\t\t\tvar rotationDiff = newGlobalRot.mult(p.globalRot.inverse());\n\t\t\t// the character body cannot rotate because fixedRotation=true\n\t\t\tvar vec = {};\n\t\t\trotationDiff.toEuler(vec);\n\t\t\t// we add the rotation to the horizontal plane\n\t\t\tthis.addRotation(vec.y);\n\t\t}\n\t};\n\t/**\r\n  * update the local position and orientation of the character\r\n  * relative to the platform\r\n  */\n\tCharacter.prototype.updatePlatform = function () {\n\t\tif (this.platform) {\n\t\t\t// if the platform is not null\n\t\t\t// position of the platform\n\t\t\tthis.platform.globalPos = this.body.position.clone();\n\t\t\tthis.platform.localPos = this.platform.body.pointToLocalFrame(this.platform.globalPos);\n\t\t\t// orientation of the platform\n\t\t\tthis.platform.globalRot = this.body.quaternion.clone();\n\t\t\tthis.platform.localRot = this.platform.body.quaternion.inverse().mult(this.platform.globalRot);\n\t\t}\n\t};\n\t/**\r\n  * Function to manage character height and crounching\r\n  */\n\tCharacter.prototype.updateCrounch = function (crounch) {\n\t\tvar canGetUp = true;\n\t\tif (crounch) {\n\t\t\tcanGetUp = false;\n\t\t\tthis.isCrounched = true;\n\t\t} else if (this.isCrounched) {\n\t\t\t// we try each vertices we have defined for characters\n\t\t\t// as long as canGetUp is not false\n\t\t\tfor (var i = 0; i < this.dimensions.vertices.length && canGetUp; ++i) {\n\n\t\t\t\t// for each vertice, we move it from local to global coords\n\t\t\t\tvar vert = this.body.vadd(this.dimensions.vertices[i]);\n\t\t\t\t// we put the vertice at the top of the head shape\n\t\t\t\tvert.y += this.dimensions.head_h;\n\n\t\t\t\t// we recover the result of the contact with the ground\n\t\t\t\tvar result = Character.checkCollision(this.body.world, vert, 0.1);\n\t\t\t\tif (result.hasHit) canGetUp = false;\n\t\t\t}\n\t\t}\n\n\t\t// we recover the shape and the offset\n\t\tvar shape = this.body.shapes[0];\n\t\tvar offset = this.body.shapeOffsets[0];\n\t\tvar inc = Character.ATTRIBUTES.crounchIncrement;\n\t\tvar h;\n\t\t// if the character can stand up\n\t\tif (canGetUp) {\n\t\t\t// as long as we are not fully standing up\n\t\t\tif (shape.halfExtents.y * 2 < this.dimensions.body_h) {\n\t\t\t\t// we increase the size of the shape\n\t\t\t\tshape.halfExtents.y += inc * 2;\n\t\t\t\t// we bring the shape closer to the the origin\n\t\t\t\toffset.y -= inc;\n\n\t\t\t\t// if we have a shape bigger than expected\n\t\t\t\tif (shape.halfExtents.y * 2 >= this.dimensions.body_h) {\n\t\t\t\t\th = this.dimensions.body_height * 0.5;\n\t\t\t\t\t// we cap the values\n\t\t\t\t\tshape.halfExtents.y = h;\n\t\t\t\t\toffset.y = -h;\n\t\t\t\t\t// the character is no longer crounched\n\t\t\t\t\tthis.isCrounched = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// cannot stand up\n\t\t\t// as long as we are not fully crounched\n\t\t\tif (shape.halfExtents.y * 2 > this.dimensions.body_c) {\n\t\t\t\t// we decrease the size of the shape\n\t\t\t\tshape.halfExtents.y -= inc * 2;\n\t\t\t\t// we put the shape farther from the origin\n\t\t\t\toffset.y += inc;\n\n\t\t\t\t// if we have a shape smaller than expected\n\t\t\t\tif (shape.halfExtents.y * 2 < this.dimensions.body_c) {\n\t\t\t\t\th = this.dimensions.body_c * 0.5;\n\t\t\t\t\t// we cap the values\n\t\t\t\t\tshape.halfExtents.y = h;\n\t\t\t\t\toffset.y = -h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tCharacter.prototype.setWeapon = function (index) {\n\t\t// if the weapons array is empty or we haven't specified a weapon to switch to\n\t\tif (this.weapons.length === 0 && index === null) return; //there is nothing to do\n\t\t// what will be the new weapon of the player ?\n\t\tvar newWeap = this.currentWeapon;\n\t\t// if index is positive\n\t\tif (-1 < index && index < this.weapons.length) {\n\t\t\t// if a weapon exists at the index position\n\t\t\tif (this.weapons[index] !== null) {\n\t\t\t\t// we set the weapon\n\t\t\t\tnewWeap = index;\n\t\t\t}\n\t\t} else {\n\t\t\t// if index==-1 : previous weapon, if index==-2 : next weapon\n\t\t\tvar incre = index == -1 ? -1 : +1;\n\t\t\t// we loop weapons.length times at max to avoid endless loop\n\t\t\tfor (var i = 0, stop = false; i < this.weapons.length || stop; ++i) {\n\t\t\t\t// we increament or decreament the value\n\t\t\t\tnewWeap += incre;\n\t\t\t\t// we cap the value\n\t\t\t\tif (newWeap >= this.weapons.length) newWeap = 0;else if (newWeap < 0) newWeap = this.weapons.length - 1;\n\t\t\t\t// if we found a weapon which is not null, we stop the loop\n\t\t\t\tif (this.weapons[newWeap] !== null) stop = true;\n\t\t\t}\n\t\t}\n\n\t\t// we call the necessary functions to update the display in HERSTALclient\n\n\t\t// we can store the new weapon as the current weapon now\n\t\tthis.currentWeapon = newWeap;\n\t};\n\n\tCharacter.prototype.getDamage = function (damage) {\n\t\t// if the character as some armor\n\t\tif (this.armor > 0) {\n\t\t\tvar armorDamage = damage * Character.ATTRIBUTES.armorProtection;\n\t\t\tdamage -= armorDamage; // we reduce the overall damage\n\t\t\tthis.armor -= armorDamage; // we apply damage to the armor\n\t\t\t// if there was more damage than expected\n\t\t\tif (this.armor < 0) {\n\t\t\t\t// we apply the difference\n\t\t\t\tdamage -= this.armor;\n\t\t\t\tthis.armor = 0;\n\t\t\t}\n\t\t}\n\t\tthis.health -= damage;\n\t\t// if health reach 0, the character is dead\n\t\tif (this.health <= 0) this.isDead = true;\n\t};\n\n\tCharacter.prototype.getHealth = function (health) {\n\t\tthis.health += health;\n\t\t// if health is higher than max, we cap the value\n\t\tif (this.health > this.maxHealth) this.health = this.maxHealth;\n\t};\n\n\tCharacter.prototype.getArmor = function (armor) {\n\t\tthis.armor += armor;\n\t\t// if health is higher than max, we cap the value\n\t\tif (this.armor > this.maxArmor) this.armor = this.maxArmor;\n\t};\n\n\tCharacter.prototype.killed = function (callback) {\n\n\t\tcallback();\n\t};\n\n\t/* STATIC ATTRIBUTES */\n\tvar fw = 0.8,\n\t    fh = 1.8,\n\t    fc = 1.0;\n\tvar hw = 0.6,\n\t    hh = 0.4; // head dimensions\n\tvar bw = fw,\n\t    bh = fh - hh,\n\t    bc = fc - hh; // body dim = full dim - head dim\n\n\t// character dimensions\n\tCharacter.DIMENSIONS = {\n\t\thead_w: hw,\n\t\thead_h: hh,\n\t\tbody_w: bw,\n\t\tbody_h: bh,\n\t\tbody_c: bc,\n\t\t// vertices used for ground and ceiling detection\n\t\tvertices: [{ x: 0, z: 0 }, { x: bw, z: bw }, { x: bw, z: -bw }, { x: -bw, z: bw }, { x: -bw, z: -bw }]\n\t};\n\n\tCharacter.checkCollision = function (world, vertice) {\n\t\tvar padding = arguments.length <= 2 || arguments[2] === undefined ? 0.1 : arguments[2];\n\n\t\t// we create the starting and ending points of the rays\n\t\tvar from = new CANNON.Vec3(vertice.x, vertice.y, vertice.z);\n\t\tvar to = from.vadd({ y: padding });\n\t\tvar ray = new CANNON.Ray(from, to);\n\n\t\t// we check collision with the world\n\t\tray.intersectWorld(world, {\n\t\t\tmode: Ray.CLOSEST,\n\t\t\tskipBackfaces: true,\n\t\t\tcollisionFilterGroup: 1,\n\t\t\tcollisionFilterMask: 1\n\t\t});\n\t\t// we return the results rather than just hasHit\n\t\treturn ray.result;\n\t};\n\n\t// attributes of the character\n\tCharacter.ATTRIBUTES = {\n\t\tdefaultHealth: 100, // health of the character on spawn\n\t\tmaxHealth: 100, // maximum health for the character\n\t\tdefaultArmor: 0, // armor of the character on spawn\n\t\tmaxArmor: 100, // maximum armor for the character\n\t\tarmorProtection: 2 / 3, // number of hit taken by the armor\n\t\tmoveSpeed: 20, // movement speed standing up\n\t\tcrounchedSpeed: 10, // movement speed crounched\n\t\tjumpForce: 30, // jump force\n\t\tjumpTimer: 10, // time before registering jumps\n\t\tcrounchIncrement: 0.05, // time between standing and crounching\n\t\tsteepSlope: 50 };\n\n\t/* bit definition:\r\n \t4 : TEAM BETA\r\n \t3 : TEAM ALPHA\r\n \t2 : NO TEAM\r\n \t1 : CHARACTER\r\n \t0 : WORLD\r\n */\n\t// Team definition\n\t// maximum angle for walking on slopes\n\tCharacter.FILTERS = {\n\t\tnone: { group: 7, mask: 7 }, // NO TEAM\n\t\talpha: { group: 11, mask: 11 }, // TEAM ALPHA\n\t\tbeta: { group: 19, mask: 19 } };\n\n\t/**\r\n  * Player informations for both server and client\r\n  * name of the player and its colors: primary, secondary and laser\r\n  */\n\n\t// TEAM BETA\n\tfunction Player(id, name, colors, model) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.colors = colors;\n\t\tthis.team = \"none\";\n\t\tthis.model = model;\n\n\t\tthis.character = null;\n\t}\n\t// we add the class to the module\n\tHERSTALshared.Player = Player;\n\tPlayer.prototype.constructor = Player;\n\n\tPlayer.prototype.createCharacter = function (position, orientation) {\n\t\tthis.character = new Character(this, position, orientation, { team: this.team });\n\t};\n\n\tfunction World() {\n\n\t\tthis.step = 1 / HERSTALshared.__FPS;\n\n\t\tthis.cannonWorld = new CANNON.World();\n\t\tthis.cannonWorld.gravity.set(0, -100, 0);\n\t\tthis.cannonWorld.defaultContactMaterial.friction = 0.1;\n\n\t\t// worldRender used in HERSTALclient\n\t\tthis.worldRender = null;\n\n\t\t// we create a new material for the characters\n\t\tthis.characterMaterial = new CANNON.Material(\"character\");\n\t\tthis.cannonWorld.addContactMaterial(new CANNON.ContactMaterial(Character.MATERIAL, WORLD.defaultMaterial, {\n\t\t\tfriction: 0,\n\t\t\trestitution: 0,\n\t\t\tcontactEquationStiffness: 1e8,\n\t\t\tcontactEquationRelaxation: 3\n\t\t}));\n\n\t\tthis.characters = [];\n\t}\n\tHERSTALshared.World = World;\n\tWorld.prototype.constructor = World;\n\n\t/**\r\n  * The function that must be executed 60 times per seconds\r\n  */\n\tWorld.prototype.update = function () {\n\t\tvar i;\n\t\t// we update the overall movement of the characters\n\t\tfor (i = 0; i < this.characters.length; ++i) {\n\t\t\tthis.characters[i].updateAll();\n\t\t}\n\t\t// we update the world physics\n\t\tworld.step(this.step);\n\t\t// we update the position of the characters based on the platform he's standing on\n\t\tfor (i = 0; i < this.characters.length; ++i) {\n\t\t\tthis.characters[i].updatePlatformPosition();\n\t\t}\n\t};\n\n\tWorld.prototype.addCharacter = function (character) {\n\t\t// we keep track of it in a list\n\t\tthis.characters.addElement(character);\n\t\t// the character is part of this world\n\t\tcharacter.world = this;\n\t\t// we add its body to the cannonWorld\n\t\tthis.cannonWorld.addBody(character.body);\n\n\t\t// if HERSTALclient is defined\n\t\tif (this.worldRender && character.characterModel) {\n\t\t\tthis.worldRender.addCharacterModel(character.characterModel);\n\t\t}\n\t};\n\n\tWorld.prototype.removeCharacter = function (character) {\n\t\tvar index = this.characters.removeElement(character);\n\t\t// if the character was in the array\n\t\tif (index > -1) {\n\t\t\tcharacter.world = null;\n\t\t\tthis.cannonWorld.removeBody(character.body);\n\n\t\t\t// if HERSTALclient is defined\n\t\t\tif (this.worldRender && character.characterModel) {\n\t\t\t\tthis.worldRender.removeCharacter(character.characterModel);\n\t\t\t}\n\t\t}\n\t};\n\n\tWorld.FILTER = { group: 7, mask: 7 };\n})();"],"sourceRoot":"/source/"}