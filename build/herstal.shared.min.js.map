{"version":3,"sources":["herstal.shared.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","Weapon","name","character","options","this","damage","maxAmmo","ammo","firerate","acquired","notAcquired","team","isSelf","player","current","filter","FILTERS","none","fg","filterGroup","fm","filterMask","group","mask","Character","position","orientation","weapons","world","inputs","currentWeapon","characterModel","health","maxHealth","armor","maxArmor","isDead","moveSpeed","crounchSpeed","jumpForce","hw","headWidth","hh","headHeight","fw","fullWidth","fh","fullHeight","bw","bodyWitdh","bh","bodyHeight","fc","fullCrounched","bc","bodyCrounched","hc","bodyWidth","vertices","x","z","y","isGounded","isCrounched","jumpTimer","platform","head_pos","body_pos","head_shape","CANNON","Box","body_shape","body","Body","mass","material","MATERIAL","fixedRotation","collisionFilterGroup","collisionFilterMask","addShape","noHead","isHead","Player","id","colors","model","weaponAutoSwitch","World","step","HERSTALshared","__FPS","cannonWorld","gravity","set","defaultContactMaterial","friction","worldRender","characterMaterial","Material","addContactMaterial","ContactMaterial","WORLD","defaultMaterial","restitution","contactEquationStiffness","contactEquationRelaxation","characters","window","module","exports","require","Error","Vec3","getAngle","v","v1","clone","v2","UNIT_Y","normalize","Math","acos","dot","Array","addElement","e","index","indexOf","length","removeElement","splice","fire","secondary","alpha","beta","self_none","self_alpha","self_beta","setFromInput","o","movement","m","jump","i","crounch","fire1","fire2","use","reload","melee","zoom","weapon","w","setFromData","data","setLook","p","copy","velocity","isGrounded","getData","g","c","updateAll","updateGround","updateMove","updateCrounch","updatePlatform","setWeapon","PI2","PI","hPI","addRotation","angle","axis","sqrLength","sqrt","theta","speed","crounchedSpeed","cos","sin","JUMP_TIMER","dimensions","vert","vadd","shapes","halfExtents","result","checkCollision","hasHit","hitNormalWorld","STEEP_SLOPE","type","KINEMATIC","hasChanged","updatePlatformPosition","newGlobalPos","pointToWorldFrame","localPos","translation","vsub","globalPos","newGlobalRot","quaternion","mult","localRot","rotationDiff","globalRot","inverse","vec","toEuler","pointToLocalFrame","canGetUp","h","shape","offset","shapeOffsets","inc","CROUNCH_INCREMENT","newWeap","incre","stop","addDamage","armorDamage","ARMOR_PROTECTION","addHealth","addArmor","killed","callback","vertice","padding","arguments","undefined","from","to","ray","Ray","intersectWorld","mode","CLOSEST","skipBackfaces","createCharacter","update","addCharacter","addBody","addCharacterModel","removeCharacter","removeBody","FILTER","Launcher","_Weapon","projectile","getPrototypeOf"],"mappings":"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","file":"herstal.shared.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n(function () {\n\tvar HERSTALshared = {\n\t\t__FPS: 60 // we fix the overall update to 60FPS\n\t};\n\n\t// we use a hack to be able to use the library in both node an the browser\n\t// if window is not set, we will have an error\n\tif (!window) window = {};\n\t// if module is not set, we will have an error\n\tif (!module) module = {};\n\n\t// the library must be usable in both node and browser\n\tmodule.exports = window.HERSTALshared = HERSTALshared;\n\n\t// Cannon is either already part of the html page or is a module to import\n\tvar CANNON = CANNON || require('./cannon.js');\n\tif (!CANNON) throw new Error('Herstal.shared needs CANNON.js to work');\n\n\t// adds function for CANNON.js objects\n\t/**\r\n Get the angle between this vector and the given vector.\r\n @method getAngle\r\n @param {Vec3} v Vector to get the angle from\r\n @return {Number} the angle between both vectors\r\n */\n\tCANNON.Vec3.prototype.getAngle = function (v) {\n\t\t// we need two vectors\n\t\tvar v1 = this.clone();\n\t\tvar v2 = v ? new CANNON.Vec3(v.x, v.y, v.z) : CANNON.Vec3.UNIT_Y;\n\n\t\t// acos(dot(v1 / norm(v1), v2 / norm(v2)))\n\t\tv1.normalize();\n\t\tv2.normalize();\n\t\treturn Math.acos(v1.dot(v2));\n\t};\n\t/**\r\n Add element only if it's not already present in the list\r\n */\n\tArray.prototype.addElement = function (e) {\n\t\tvar index = this.indexOf(e);\n\t\t// if the element is not already in the list\n\t\t// we add it to the end of the list\n\t\tif (index == -1) {\n\t\t\tthis[this.length] = e;\n\t\t\t// we return the position of the element in the array\n\t\t\treturn this.length - 1;\n\t\t}\n\t\treturn -1; // the element was already in the array\n\t};\n\t/**\r\n Remove an element from the list\r\n */\n\tArray.prototype.removeElement = function (e) {\n\t\tvar index = this.indexOf(e);\n\t\t// if the element is in the list\n\t\t// we can remove it\n\t\tif (index > -1) this.splice(index, 1);\n\t\t// we return the old position of the element in the array\n\t\treturn index;\n\t};\n\n\t/**\r\n Base class for all weapons\r\n @class Weapon\r\n */\n\t/* CONSTRUCTOR */\n\t/**\r\n @constructor\r\n @param {String}    name      The name of the weapon\r\n @param {Character} character The character holding the weapon\r\n @param\r\n */\n\tfunction Weapon(name, character, options) {\n\t\toptions = options || {};\n\t\t// set name of the weapon and the character using it\n\t\tthis.name = name;\n\t\tthis.character = character;\n\t\tthis.damage = options.damage || 0;\n\t\t// if maxAmmo is set and greater than 0\n\t\tif (options.maxAmmo > 0) {\n\t\t\tthis.ammo = options.ammo;\n\t\t\tthis.maxAmmo = options.maxAmmo;\n\t\t}\n\t\tthis.firerate = options.firerate > 0 ? options.firerate : 60;\n\t\tthis.acquired = !options.notAcquired;\n\n\t\t// which group and mask should we use for this weapon ?\n\t\tvar team = options.team || \"none\";\n\t\t// should we use self_ group and mask ?\n\t\tvar isSelf = this.character.player.current ? \"self_\" : \"\";\n\t\tvar filter = Weapon.FILTERS[isSelf + team] || Weapon.FILTERS.none;\n\t\tvar fg = options.filterGroup,\n\t\t    fm = options.filterMask;\n\t\tthis.filterGroup = fg != null ? fg : filter.group;\n\t\tthis.filterMask = fm != null ? fm : filter.mask;\n\t}\n\t// we add the class to the module\n\tWeapon.prototype.constructor = HERSTALshared.Weapon = Weapon;\n\n\tWeapon.prototype.fire = function () {};\n\n\tWeapon.prototype.secondary = function () {};\n\n\tWeapon.FILTERS = {\n\t\tnone: { group: 1, mask: 1 },\n\t\talpha: { group: 1, mask: 1 },\n\t\tbeta: { group: 1, mask: 1 },\n\t\tself_none: { group: 1, mask: 1 },\n\t\tself_alpha: { group: 1, mask: 1 },\n\t\tself_beta: { group: 1, mask: 1 }\n\t};\n\n\t/**\r\n Base class for all characters\r\n @class Character\r\n */\n\t/* CONSTRUCTOR */\n\t/**\r\n Create a character for the player at the given position\r\n @constructor\r\n @param {Player} player   Player which will be represented by the character\r\n @param {Vec3}   position Foot position of the character\r\n @param {Number} orientation Angle of the character at start\r\n @param {Object} options Optional configurations\r\n @param {Number} options.health\r\n \tThe health of the character\r\n @param {Number} options.maxHealth\r\n \tThe maximum health of the character (if < 0, no capping)\r\n @param {Number} options.armor\r\n \tThe armor of the character (if null, no armor)\r\n @param {Number} options.maxArmor\r\n \tThe maximum armor of the character (if null, no capping)\r\n @param {Number} options.moveSpeed\r\n \tThe speed of the character when walking\r\n @param {Number} options.crounchSpeed\r\n \tThe speed of the character when crounched\r\n @param {Number} options.jumpForce\r\n \tThe force applied to the character when jumping\r\n @param {Number} options.fullWidth\r\n \tThe width of the character\r\n @param {Number} options.fullHeight\r\n \tThe full height of the character when standing up\r\n @param {Number} options.fullCrounched\r\n \tThe full height of the character when crounched\r\n @param {Number} options.bodyWidth\r\n \tThe width of the character\r\n @param {Number} options.bodyHeight\r\n \tThe height of the body part of the character when standing up\r\n @param {Number} options.bodyCrounched\r\n \tThe height of the body part of the character when crounched\r\n @param {Number} options.headWidth\r\n \tThe width of the head part of the character\r\n @param {Number} options.headHeight\r\n \tThe height of the head part of the character\r\n @param {String} options.team\r\n \tThe team identificator of the character (\"none\", \"alpha\", \"beta\")\r\n \tAlso set automatically filterGroup and filterMask\r\n @param {Number} options.filterGroup\r\n \tOverride the character filterGroup\r\n @param {Number} options.filterMask\r\n \tOverride the character filterMask\r\n @param {Boolean} options.noHead\r\n \tTells if the head part should have the isHead property\r\n */\n\tfunction Character(player, position, orientation, weapons, options) {\n\t\toptions = options || {};\n\n\t\t// the world in which the character exists\n\t\tthis.world = null;\n\t\tthis.player = player;\n\t\tthis.inputs = null;\n\t\t// weapons of the character (max should be 10)\n\t\t// the array needs atleast one weapon\n\t\tthis.weapons = weapons || [new Weapon(\"none\", this)];\n\t\tthis.currentWeapon = 0;\n\n\t\t// characterModel used in HERSTALclient\n\t\tthis.characterModel = null;\n\n\t\t// status of the character\n\t\tthis.health = options.health || 100;\n\t\tthis.maxHealth = options.maxHealth || 100;\n\t\tthis.armor = options.armor;\n\t\tthis.maxArmor = options.maxArmor;\n\t\tthis.isDead = false;\n\t\t// movement of the character\n\t\tthis.moveSpeed = options.moveSpeed || 20;\n\t\tthis.crounchSpeed = options.crounchSpeed || 10;\n\t\tthis.jumpForce = options.jumpForce || 30;\n\n\t\t// we set the dimensions of the character\n\t\tvar hw = options.headWidth,\n\t\t    hh = options.headHeight,\n\t\t    fw = options.fullWidth,\n\t\t    fh = options.fullHeight,\n\t\t    bw = options.bodyWitdh,\n\t\t    bh = options.bodyHeight,\n\t\t    fc = options.fullCrounched,\n\t\t    bc = options.bodyCrounched;\n\t\t// if no dimensions are set, we use the default values\n\t\thw = hw > 0 ? hw : 0.6;\n\t\thh = hh > 0 ? hh : 0.4;\n\t\t// is full height setted ?\n\t\tif (fh > 0) fh -= hh;\n\t\tif (hc > 0) fc -= hh;\n\t\t// either use body or full dimensions\n\t\tbw = bw || fw;\n\t\tbh = bh || fh;\n\t\tbc = bc || fc;\n\t\t// we correct the body dimensions\n\t\tbw = bw > 0 ? bw : 0.8;\n\t\tbh = bh > 0 ? bh : 1.4;\n\t\tbc = bc > 0 ? bc : 0.6;\n\t\t// we add those information to the character\n\t\tthis.headWidth = hw;\n\t\tthis.headHeight = hh;\n\t\tthis.bodyWidth = bw;\n\t\tthis.bodyHeight = bh;\n\t\tthis.bodyCrounched = bc;\n\t\t// we store vertices for ground and ceiling check\n\t\tthis.vertices = [{ x: 0, z: 0 }, { x: bw, z: bw }, { x: bw, z: -bw }, { x: -bw, z: bw }, { x: -bw, z: -bw }];\n\n\t\t// position of the new character\n\t\tposition = position || { x: 0, y: 0, z: 0 };\n\t\t// the origin of the character will be placed at neck level\n\t\tposition.y += this.bodyHeight;\n\n\t\t// the orientation of the head (not a quaternion)\n\t\tthis.orientation = { x: orientation || 0, y: 0 };\n\n\t\t// state of the character\n\t\tthis.isGounded = false;\n\t\tthis.isCrounched = false;\n\t\t// jump timer gives a time interval in which the character can jump\n\t\tthis.jumpTimer = 0;\n\t\t// contains the information about the platform the character is standing on\n\t\tthis.platform = null; // only requiered for moving platforms\n\n\t\t// relative position of the shapes of the character\n\t\tvar head_pos = { x: 0, z: 0, y: 0.5 * hh };\n\t\tvar body_pos = { x: 0, z: 0, y: -0.5 * bh };\n\t\t// shapes of the character\n\t\tvar head_shape = new CANNON.Box({ x: hw, y: hh, z: hw });\n\t\tvar body_shape = new CANNON.Box({ x: bw, y: bh, z: bw });\n\n\t\t// we recover the filter based on the team of the player\n\t\tvar team = options.team || \"none\";\n\t\t// should we use self_ group and mask ?\n\t\tvar isSelf = this.player.current ? \"self_\" : \"\";\n\t\tvar filter = Character.FILTERS[isSelf + team] || Character.FILTERS.none;\n\t\tvar fg = options.filterGroup,\n\t\t    fm = options.filterMask;\n\t\tfg = fg != null ? fg : filter.group;\n\t\tfm = fm != null ? fm : filter.mask;\n\n\t\t// we create the body collider of the character\n\t\tthis.body = new CANNON.Body({\n\t\t\tposition: position,\n\t\t\tmass: 10,\n\t\t\tmaterial: Character.MATERIAL,\n\t\t\tfixedRotation: true,\n\t\t\tcollisionFilterGroup: fg,\n\t\t\tcollisionFilterMask: fm\n\t\t});\n\t\t// we add both shapes to the body\n\t\tthis.body.addShape(body_shape, body_pos); // shape 0 = body\n\t\tthis.body.addShape(head_shape, head_pos); // shape 1 = head\n\n\t\t// we add more information to the bodies\n\t\tthis.body.character = this; // a reference to the character\n\t\tif (!options.noHead) head_shape.isHead = true; // this shape is the head\n\t}\n\t// we add the class to the module\n\tHERSTALshared.Character = Character;\n\tCharacter.prototype.constructor = Character;\n\n\t/* SETTER GETTER */\n\t/**\r\n Store all of the inputs set over JSON\r\n @method setFromInput\r\n @param {Object} inputs   Inputs loaded from JSON\r\n @param {Vec2}   inputs.o Orientation of the character\r\n @param {Vec2}   inputs.m Movement of the character\r\n @param {Number} inputs.i Array of bits:\r\n \t[0] jump\r\n \t[1] crounch\r\n \t[2] fire1\r\n \t[3] fire2\r\n \t[4] use\r\n \t[5] reload\r\n \t[6] melee\r\n \t[7] zoom\r\n @param {Number} inputs.w Weapon selection\r\n */\n\tCharacter.prototype.setFromInput = function (inputs) {\n\t\t// if inputs is empty, there is nothing to do\n\t\tif ((typeof inputs === 'undefined' ? 'undefined' : _typeof(inputs)) !== \"object\") return;\n\t\tthis.inputs = {};\n\n\t\tthis.inputs.orientation = inputs.o;\n\t\tthis.inputs.movement = inputs.m;\n\t\tthis.inputs.jump = !!(inputs.i & 1);\n\t\tthis.inputs.crounch = !!(inputs.i & 2);\n\t\tthis.inputs.fire1 = !!(inputs.i & 4);\n\t\tthis.inputs.fire2 = !!(inputs.i & 8);\n\t\tthis.inputs.use = !!(inputs.i & 16);\n\t\tthis.inputs.reload = !!(inputs.i & 32);\n\t\tthis.inputs.melee = !!(inputs.i & 64);\n\t\tthis.inputs.zoom = !!(inputs.i & 128);\n\t\tthis.inputs.weapon = inputs.w;\n\t};\n\t/*\r\n to avoid overflood json files with names, we use short names:\r\n o : orientation\r\n p : position\r\n v : velocity\r\n g : isGrounded\r\n c : isCrounched\r\n */\n\t/**\r\n Set all of the position and movement of the character from the data object\r\n @method setFromData\r\n @param {Object} data   Data setting the state of the character\r\n @param {Vec2}   data.o Orientation of the character\r\n @param {Vec3}   data.p Position of the character\r\n @param {Vec3}   data.v Velocity of the character\r\n @param {Number} data.i Array of bits:\r\n \t[0] is grounded\r\n \t[1] is crounched\r\n \t[2] is jumping\r\n \t[3] is firing\r\n \t[4] is reloading\r\n */\n\tCharacter.prototype.setFromData = function (data) {\n\t\t// if data is empty, there is nothing to do\n\t\tif ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== \"object\") return;\n\t\t// we update the orientation of the character\n\t\tthis.setLook(data.o);\n\n\t\t// if the position is set\n\t\tif (_typeof(data.p) === \"object\") {\n\t\t\t// if position is a vector 3\n\t\t\tif (_typeof(data.p.x) === _typeof(data.p.y) === _typeof(data.p.z) === \"number\") {\n\t\t\t\tthis.body.position.copy(data.p);\n\t\t\t}\n\t\t}\n\t\t// if the velocity is set\n\t\tif (_typeof(data.v) === \"object\") {\n\t\t\t// if velocity is a vector 3\n\t\t\tif (_typeof(data.v.x) === _typeof(data.v.y) === _typeof(data.v.z) === \"number\") {\n\t\t\t\tthis.body.velocity.copy(data.v);\n\t\t\t}\n\t\t}\n\t\t// set the state of the character\n\t\t/*jshint eqnull: true*/\n\t\tif (data.i != null) {\n\t\t\tthis.isGrounded = !!(data.i & 1);\n\t\t\tthis.isCrounched = !!(data.i & 2);\n\t\t}\n\t};\n\t/**\r\n Read all of the position and movement of the character\r\n and create a object out of them\r\n */\n\tCharacter.prototype.getData = function () {\n\t\treturn {\n\t\t\to: this.orientation,\n\t\t\tp: {\n\t\t\t\tx: this.body.position.x,\n\t\t\t\ty: this.body.position.y,\n\t\t\t\tz: this.body.position.z\n\t\t\t},\n\t\t\tv: {\n\t\t\t\tx: this.body.velocity.x,\n\t\t\t\ty: this.body.velocity.y,\n\t\t\t\tz: this.body.velocity.z\n\t\t\t},\n\t\t\tg: this.isGrounded,\n\t\t\tc: this.isCrounched\n\t\t};\n\t};\n\n\t/* UPDATE FUNCTIONS */\n\t/**\r\n Global update function of the character\r\n */\n\tCharacter.prototype.updateAll = function () {\n\t\tvar inputs = this.inputs || {};\n\n\t\t// where the character is looking at ?\n\t\tthis.setLook(inputs.orientation);\n\t\t// is the character on the ground ?\n\t\tthis.updateGround();\n\t\t// in which direction the character is moving, is he jumping ?\n\t\tthis.updateMove(inputs.movement, inputs.jump);\n\t\t// is the character crounching ?\n\t\tthis.updateCrounch(inputs.crounch);\n\t\t// if the character is on a platform, we should record it's position\n\t\tthis.updatePlatform();\n\t\t// we update the weapon the character is holding\n\t\tthis.setWeapon(inputs.weapon);\n\t};\n\t/**\r\n Allow the character to look around\r\n calculation based on mouse delta is performed client side\r\n */\n\tCharacter.prototype.setLook = function (orientation) {\n\t\t// if orientation is set\n\t\tif (orientation) {\n\t\t\tvar PI2 = Math.PI * 2,\n\t\t\t    hPI = Math.PI * 0.5;\n\t\t\t// we keep angle in the [ -2PI, 2PI ] interval\n\t\t\torientation.x %= PI2;\n\t\t\torientation.y %= PI2;\n\t\t\t// we cap the angle on the Y-axis within [ -PI/2, PI/2 ] interval\n\t\t\tif (orientation.y > hPI) orientation.y = hPI;else if (orientation.y < -hPI) orientation.y = -hPI;\n\t\t\t// we apply the orientation\n\t\t\tthis.orientation = orientation;\n\t\t}\n\t};\n\t/**\r\n Allow to add more rotation to the character on the Y-axis\r\n */\n\tCharacter.prototype.addRotation = function (angle) {\n\t\t// we add the angle on the Y-axis\n\t\tthis.orientation.x += angle;\n\t\tthis.orientation.x %= Math.PI * 2;\n\t};\n\t/**\r\n Allow the character to move around\r\n Movement calculation is performed both client and server side\r\n server has the authority over the client\r\n */\n\tCharacter.prototype.updateMove = function (axis, jump) {\n\t\t// if axis is not set, we set it to vector null\n\t\taxis = axis || { x: 0, y: 0 };\n\n\t\t// we normalize the vector to avoid cheating\n\t\tvar sqrLength = axis.x * axis.x + axis.y * axis.y;\n\t\tif (sqrLength > 1) {\n\t\t\tvar length = Math.sqrt(sqrLength);\n\t\t\taxis.x /= length;\n\t\t\taxis.y /= length;\n\t\t}\n\n\t\t// we need the angle on the x axis (horizontal plane)\n\t\tvar theta = this.orientation.x;\n\t\tvar speed = this.isCrounched ? this.crounchedSpeed : this.moveSpeed;\n\n\t\t// we create a new velocity vector\n\t\tvar velocity = {\n\t\t\ty: this.body.velocity.y,\n\t\t\tx: (axis.x * Math.cos(theta) - axis.y * Math.sin(theta)) * speed,\n\t\t\tz: (-axis.x * Math.sin(theta) - axis.y * Math.cos(theta)) * speed\n\t\t};\n\n\t\t// if the player pressed the jump input\n\t\tif (jump) this.jumpTimer = Character.JUMP_TIMER;\n\n\t\t// if the jump timer is set, we decreament it\n\t\tif (this.jumpTimer > 0) --this.jumpTimer;\n\n\t\t// if the character is on the ground\n\t\tif (this.isGrounded) {\n\t\t\t// if the character wants to jump\n\t\t\tif (this.jumpTimer > 0) {\n\t\t\t\t// we reset the timer, the character jumps once\n\t\t\t\tthis.jumpTimer = 0;\n\t\t\t\t// we apply a vertical velocity\n\t\t\t\tvelocity.y = this.jumpForce;\n\t\t\t}\n\t\t} else {\n\t\t\t// in the air, the new velocity is influenced by the old one\n\t\t\t// new_vel = new_vel/2 + old_vel/2;\n\t\t\tvelocity.x += this.body.velocity.x;\n\t\t\tvelocity.z += this.body.velocity.z;\n\t\t\tvelocity.x *= 0.5;\n\t\t\tvelocity.z *= 0.5;\n\t\t}\n\t\tthis.body.velocity = velocity;\n\t};\n\t/**\r\n Function to know if the character is on the ground or not\r\n */\n\tCharacter.prototype.updateGround = function () {\n\t\t// we reset the state of the character\n\t\tthis.isGrounded = false;\n\t\t// we try each vertices we have defined for characters\n\t\tfor (var i = 0; i < this.dimensions.vertices.length; ++i) {\n\n\t\t\t// for each vertice, we move it from local to global coords\n\t\t\tvar vert = this.body.vadd(this.dimensions.vertices[i]);\n\t\t\t// we put the vertice at the base of the body shape\n\t\t\tvert.y -= this.body.shapes[0].halfExtents.y * 2; // shape 0 is body\n\n\t\t\t// we recover the result of the contact with the ground\n\t\t\tvar result = Character.checkCollision(this.body.world, vert, -0.1);\n\t\t\tif (result.hasHit) {\n\n\t\t\t\t// the angle between the surface normal and the vector up\n\t\t\t\tvar angle = result.hitNormalWorld.getAngle(CANNON.Vec3.UNIT_Y);\n\t\t\t\t// if the ground on which the character stand is not too steep\n\t\t\t\tif (angle < Character.STEEP_SLOPE) {\n\n\t\t\t\t\t// we are on a ground\n\t\t\t\t\tthis.isGrounded = true;\n\t\t\t\t\t// if the platform on which we land is kinematic\n\t\t\t\t\tif (result.body.type === CANNON.Body.KINEMATIC) {\n\n\t\t\t\t\t\t// did we changed of platform ?\n\t\t\t\t\t\tvar hasChanged = false;\n\t\t\t\t\t\tif (!platform) hasChanged = true;else if (platform.body !== result.body) hasChanged = true;\n\t\t\t\t\t\t// if the platform has changed\n\t\t\t\t\t\tif (hasChanged) {\n\t\t\t\t\t\t\t// we need to update the platform\n\t\t\t\t\t\t\tthis.platform = { body: result.body };\n\t\t\t\t\t\t\tthis.updatePlatform();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we landed on a platform which is not kinematic\n\t\t\t\t\t\tthis.platform = null;\n\t\t\t\t\t}\n\t\t\t\t\t// we've found one contact point\n\t\t\t\t\treturn; // we don't need to check the others\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.platform = null;\n\t};\n\t/**\r\n Update the position of the character based on\r\n the position of the moving platform he is standing on\r\n /!\\ Should be called after physic engine calculations /!\\\r\n */\n\tCharacter.prototype.updatePlatformPosition = function () {\n\t\tvar p = this.platform;\n\t\tif (p) {\n\t\t\t// if the character is standing on a platform\n\n\t\t\t// we calculate the movement of the platform since the last update\n\t\t\tvar newGlobalPos = p.pointToWorldFrame(p.localPos);\n\t\t\tvar translation = newGlobalPos.vsub(p.globalPos);\n\t\t\t// we apply the movement to the player\n\t\t\tthis.body.position = this.body.position.vadd(translation);\n\n\t\t\t// we calculate the rotation of the platform since the last update\n\t\t\tvar newGlobalRot = p.body.quaternion.mult(p.localRot);\n\t\t\tvar rotationDiff = newGlobalRot.mult(p.globalRot.inverse());\n\t\t\t// the character body cannot rotate because fixedRotation=true\n\t\t\tvar vec = {};\n\t\t\trotationDiff.toEuler(vec);\n\t\t\t// we add the rotation to the horizontal plane\n\t\t\tthis.addRotation(vec.y);\n\t\t}\n\t};\n\t/**\r\n Update the local position and orientation of the character\r\n relative to the platform\r\n */\n\tCharacter.prototype.updatePlatform = function () {\n\t\tif (this.platform) {\n\t\t\t// if the platform is not null\n\t\t\t// position of the platform\n\t\t\tthis.platform.globalPos = this.body.position.clone();\n\t\t\tthis.platform.localPos = this.platform.body.pointToLocalFrame(this.platform.globalPos);\n\t\t\t// orientation of the platform\n\t\t\tthis.platform.globalRot = this.body.quaternion.clone();\n\t\t\tthis.platform.localRot = this.platform.body.quaternion.inverse().mult(this.platform.globalRot);\n\t\t}\n\t};\n\t/**\r\n Function to manage character height and crounching\r\n */\n\tCharacter.prototype.updateCrounch = function (crounch) {\n\t\tvar canGetUp = true;\n\t\tif (crounch) {\n\t\t\tcanGetUp = false;\n\t\t\tthis.isCrounched = true;\n\t\t} else if (this.isCrounched) {\n\t\t\t// we try each vertices we have defined for characters\n\t\t\t// as long as canGetUp is not false\n\t\t\tfor (var i = 0; i < this.dimensions.vertices.length && canGetUp; ++i) {\n\n\t\t\t\t// for each vertice, we move it from local to global coords\n\t\t\t\tvar vert = this.body.vadd(this.dimensions.vertices[i]);\n\t\t\t\t// we put the vertice at the top of the head shape\n\t\t\t\tvert.y += this.headHeight;\n\n\t\t\t\t// we recover the result of the contact with the ground\n\t\t\t\tvar result = Character.checkCollision(this.body.world, vert, 0.1);\n\t\t\t\tif (result.hasHit) canGetUp = false;\n\t\t\t}\n\t\t}\n\n\t\t// we recover the shape and the offset\n\t\tvar shape = this.body.shapes[0];\n\t\tvar offset = this.body.shapeOffsets[0];\n\t\tvar inc = Character.CROUNCH_INCREMENT;\n\t\tvar h;\n\t\t// if the character can stand up\n\t\tif (canGetUp) {\n\t\t\t// as long as we are not fully standing up\n\t\t\tif (shape.halfExtents.y * 2 < this.bodyHeight) {\n\t\t\t\t// we increase the size of the shape\n\t\t\t\tshape.halfExtents.y += inc * 2;\n\t\t\t\t// we bring the shape closer to the the origin\n\t\t\t\toffset.y -= inc;\n\n\t\t\t\t// if we have a shape bigger than expected\n\t\t\t\tif (shape.halfExtents.y * 2 >= this.bodyHeight) {\n\t\t\t\t\th = this.bodyHeight * 0.5;\n\t\t\t\t\t// we cap the values\n\t\t\t\t\tshape.halfExtents.y = h;\n\t\t\t\t\toffset.y = -h;\n\t\t\t\t\t// the character is no longer crounched\n\t\t\t\t\tthis.isCrounched = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// cannot stand up\n\t\t\t// as long as we are not fully crounched\n\t\t\tif (shape.halfExtents.y * 2 > this.bodyCrounched) {\n\t\t\t\t// we decrease the size of the shape\n\t\t\t\tshape.halfExtents.y -= inc * 2;\n\t\t\t\t// we put the shape farther from the origin\n\t\t\t\toffset.y += inc;\n\n\t\t\t\t// if we have a shape smaller than expected\n\t\t\t\tif (shape.halfExtents.y * 2 < this.bodyCrounched) {\n\t\t\t\t\th = this.bodyCrounched * 0.5;\n\t\t\t\t\t// we cap the values\n\t\t\t\t\tshape.halfExtents.y = h;\n\t\t\t\t\toffset.y = -h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tCharacter.prototype.setWeapon = function (index) {\n\t\t// if the weapons array is empty\n\t\t// or we haven't specified a weapon to switch to\n\t\t// there is nothing to do\n\t\tif (this.weapons.length === 0 && index == null) return;\n\t\t// what will be the new weapon of the player ?\n\t\tvar newWeap = this.currentWeapon;\n\t\t// if index is positive\n\t\tif (-1 < index && index < this.weapons.length) {\n\t\t\t// if a weapon exists at the index position\n\t\t\tif (this.weapons[index] != null) {\n\t\t\t\t// we set the weapon\n\t\t\t\tnewWeap = index;\n\t\t\t}\n\t\t} else {\n\t\t\t// if index==-1 : previous weapon, if index==-2 : next weapon\n\t\t\tvar incre = index == -1 ? -1 : +1;\n\t\t\t// we loop weapons.length times at max to avoid endless loop\n\t\t\tfor (var i = 0, stop = false; i < this.weapons.length || stop; ++i) {\n\t\t\t\t// we increament or decreament the value\n\t\t\t\tnewWeap += incre;\n\t\t\t\t// we cap the value\n\t\t\t\tif (newWeap >= this.weapons.length) newWeap = 0;else if (newWeap < 0) newWeap = this.weapons.length - 1;\n\t\t\t\t// if we found a weapon which is not null, we stop the loop\n\t\t\t\tif (this.weapons[newWeap] != null) stop = true;\n\t\t\t}\n\t\t}\n\n\t\t// we call the necessary functions to update the display in HERSTALclient\n\n\t\t// we can store the new weapon as the current weapon now\n\t\tthis.currentWeapon = newWeap;\n\t};\n\n\tCharacter.prototype.addDamage = function (damage) {\n\t\t// if the character as some armor\n\t\tif (this.armor > 0) {\n\t\t\tvar armorDamage = damage * Character.ARMOR_PROTECTION;\n\t\t\tdamage -= armorDamage; // we reduce the overall damage\n\t\t\tthis.armor -= armorDamage; // we apply damage to the armor\n\t\t\t// if there was more damage than expected\n\t\t\tif (this.armor < 0) {\n\t\t\t\t// we apply the difference\n\t\t\t\tdamage -= this.armor;\n\t\t\t\tthis.armor = 0;\n\t\t\t}\n\t\t}\n\t\tthis.health -= damage;\n\t\t// if health reach 0, the character is dead\n\t\tif (this.health <= 0) this.isDead = true;\n\t};\n\n\tCharacter.prototype.addHealth = function (health) {\n\t\tthis.health += health;\n\t\t// if health is higher than max\n\t\tif (this.health > this.maxHealth && this.maxHealth > 0) this.health = this.maxHealth; // we cap the value\n\t};\n\n\tCharacter.prototype.addArmor = function (armor) {\n\t\tif (this.armor != null) {\n\t\t\tthis.armor += armor;\n\t\t\t// if armor is higher than max and max not null\n\t\t\tif (this.armor > this.maxArmor && this.maxArmor != null) this.armor = this.maxArmor; // we cap the value\n\t\t}\n\t};\n\n\tCharacter.prototype.killed = function (callback) {\n\n\t\tcallback();\n\t};\n\n\tCharacter.checkCollision = function (world, vertice) {\n\t\tvar padding = arguments.length <= 2 || arguments[2] === undefined ? 0.1 : arguments[2];\n\n\t\t// we create the starting and ending points of the rays\n\t\tvar from = new CANNON.Vec3(vertice.x, vertice.y, vertice.z);\n\t\tvar to = from.vadd({ y: padding });\n\t\tvar ray = new CANNON.Ray(from, to);\n\n\t\t// we check collision with the world\n\t\tray.intersectWorld(world, {\n\t\t\tmode: Ray.CLOSEST,\n\t\t\tskipBackfaces: true,\n\t\t\tcollisionFilterGroup: 1,\n\t\t\tcollisionFilterMask: 1\n\t\t});\n\t\t// we return the results rather than just hasHit\n\t\treturn ray.result;\n\t};\n\n\t// attributes of the character\n\tCharacter.ARMOR_PROTECTION = 2 / 3; // number of hit taken by the armor\n\tCharacter.JUMP_TIMER = 10; // time before registering jumps\n\tCharacter.CROUNCH_INCREMENT = 0.05; // time between standing and crounching\n\tCharacter.STEEP_SLOPE = 50; // maximum angle for walking on slopes\n\n\t/*\r\n bit definition:\r\n \t4 : TEAM BETA\r\n \t3 : TEAM ALPHA\r\n \t2 : NO TEAM\r\n \t1 : CHARACTER\r\n \t0 : WORLD\r\n */\n\t// Team definition\n\tCharacter.FILTERS = {\n\t\tnone: { group: 7, mask: 7 }, // NO TEAM\n\t\talpha: { group: 11, mask: 11 }, // TEAM ALPHA\n\t\tbeta: { group: 19, mask: 19 }, // TEAM BETA\n\t\tself_none: { group: 1, mask: 1 },\n\t\tself_alpha: { group: 1, mask: 1 },\n\t\tself_beta: { group: 1, mask: 1 }\n\t};\n\n\t/**\r\n Player informations for both server and client\r\n name of the player and its colors: primary, secondary and laser\r\n */\n\n\tfunction Player(id, name, options) {\n\t\toptions = options || {};\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.team = \"none\";\n\n\t\tthis.character = null; // character of the player\n\t\tthis.current = null; // is it the current player ?\n\n\t\tthis.colors = options.colors;\n\t\tthis.model = options.model;\n\t\tthis.weaponAutoSwitch = options.weaponAutoSwitch;\n\t}\n\t// we add the class to the module\n\tPlayer.prototype.constructor = HERSTALshared.Player = Player;\n\n\tPlayer.prototype.createCharacter = function (position, orientation) {\n\t\tthis.character = new Character(this, position, orientation, {\n\t\t\tteam: this.team\n\t\t});\n\t};\n\n\tfunction World() {\n\n\t\tthis.step = 1 / HERSTALshared.__FPS;\n\n\t\tthis.cannonWorld = new CANNON.World();\n\t\tthis.cannonWorld.gravity.set(0, -100, 0);\n\t\tthis.cannonWorld.defaultContactMaterial.friction = 0.1;\n\n\t\t// worldRender used in HERSTALclient\n\t\tthis.worldRender = null;\n\n\t\t// we create a new material for the characters\n\t\tthis.characterMaterial = new CANNON.Material(\"character\");\n\t\tthis.cannonWorld.addContactMaterial(new CANNON.ContactMaterial(Character.MATERIAL, WORLD.defaultMaterial, {\n\t\t\tfriction: 0,\n\t\t\trestitution: 0,\n\t\t\tcontactEquationStiffness: 1e8,\n\t\t\tcontactEquationRelaxation: 3\n\t\t}));\n\n\t\tthis.characters = [];\n\t}\n\tWorld.prototype.constructor = HERSTALshared.World = World;\n\n\t/**\r\n  * The function that must be executed 60 times per seconds\r\n  */\n\tWorld.prototype.update = function () {\n\t\tvar i;\n\t\t// we update the overall movement of the characters\n\t\tfor (i = 0; i < this.characters.length; ++i) {\n\t\t\tthis.characters[i].updateAll();\n\t\t}\n\t\t// we update the world physics\n\t\tworld.step(this.step);\n\t\t// we update the position of the characters based on the platform he's standing on\n\t\tfor (i = 0; i < this.characters.length; ++i) {\n\t\t\tthis.characters[i].updatePlatformPosition();\n\t\t}\n\t};\n\n\tWorld.prototype.addCharacter = function (character) {\n\t\t// we keep track of it in a list\n\t\tthis.characters.addElement(character);\n\t\t// the character is part of this world\n\t\tcharacter.world = this;\n\t\t// we add its body to the cannonWorld\n\t\tthis.cannonWorld.addBody(character.body);\n\n\t\t// if HERSTALclient is defined\n\t\tif (this.worldRender && character.characterModel) {\n\t\t\tthis.worldRender.addCharacterModel(character.characterModel);\n\t\t}\n\t};\n\n\tWorld.prototype.removeCharacter = function (character) {\n\t\tvar index = this.characters.removeElement(character);\n\t\t// if the character was in the array\n\t\tif (index > -1) {\n\t\t\tcharacter.world = null;\n\t\t\tthis.cannonWorld.removeBody(character.body);\n\n\t\t\t// if HERSTALclient is defined\n\t\t\tif (this.worldRender && character.characterModel) {\n\t\t\t\tthis.worldRender.removeCharacter(character.characterModel);\n\t\t\t}\n\t\t}\n\t};\n\n\tWorld.FILTER = { group: 7, mask: 7 };\n\n\tvar Launcher = function (_Weapon) {\n\t\t_inherits(Launcher, _Weapon);\n\n\t\tfunction Launcher(name, character, projectile, options) {\n\t\t\t_classCallCheck(this, Launcher);\n\n\t\t\toptions = options || {};\n\t\t\t// call Weapon constructor\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Launcher).call(this, name, character, options));\n\t\t}\n\n\t\treturn Launcher;\n\t}(Weapon);\n\n\tHERSTALshared.Launcher = Launcher;\n\n\t/**\r\n Base class for raycasting weapon\r\n extends Weapon class\r\n */\n\tfunction Rifle(name, character, options) {\n\t\toptions = options || {};\n\t\tWeapon.call(this, name, character, options);\n\t}\n})();"],"sourceRoot":"/source/"}